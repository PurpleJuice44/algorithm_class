**DP on Subsets (부분집합 DP)**는 특정 집합의 부분집합에 대한 성질을 분석하고, 포함-배제 원리나 비트마스킹을 활용하여 문제를 해결하는 고급 DP 기법입니다. 이 기법은 조합 문제, 수학적 성질을 기반으로 한 문제, 또는 특정 조건을 만족하는 부분집합의 개수를 구하는 경우에 유용합니다.

---

### 🔍 **DP on Subsets (부분집합 DP) – 핵심 개념**

- **문제 특성**:  
  주어진 집합의 **부분집합** 중 특정 조건을 만족하는 경우의 수를 구하거나, 그 조건에 따라 최적 값을 구하는 문제입니다.

- **핵심 아이디어**:  
  각 원소가 포함되거나 포함되지 않음을 **비트마스킹**으로 표현하고, 모든 부분집합에 대해 DP를 수행하여 상태를 전이합니다.

- **주요 응용 예시**:
  - 특정 조건을 만족하는 부분집합의 수 구하기
  - 부분집합의 합, 곱, 최대/최소값 등에 대한 제약 조건
  - 포함-배제 원리에 기반한 조합 문제 (예: `n`개의 원소 중에서 짝수 개를 선택하는 경우)

---

### 📌 **예시 문제: 부분집합의 합이 0이 되는 경우의 수**

> 주어진 정수 배열에서, 부분집합의 합이 0이 되는 경우의 수를 구하라.

#### ✅ 풀이 (비트마스킹 + DP)

- 전체 원소 수: $ n $
- 가능한 부분집합 수: $ 2^n $
- 각 부분집합의 합을 저장하기 위해 `DP[sum]` 배열을 사용 (합의 범위 제한 필요)

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    // DP[sum] = 합이 sum인 부분집합의 수
    // 최대 합을 제한 (예: 1000)
    int max_sum = 0;
    for (int x : arr) max_sum += abs(x);
    max_sum = max_sum + 100; // 안전 범위 확보

    vector<int> dp(max_sum + 1, 0);
    dp[0] = 1; // 공집합의 합은 0

    for (int i = 0; i < n; i++) {
        vector<int> new_dp = dp;
        for (int j = 0; j <= max_sum; j++) {
            if (dp[j] > 0) {
                int new_sum = j + arr[i];
                if (new_sum <= max_sum) {
                    new_dp[new_sum] += dp[j];
                }
            }
        }
        dp = new_dp;
    }

    cout << dp[0] << endl; // 합이 0인 경우의 수 (공집합 포함)
    return 0;
}
```

> 💡 **주의**: 이 예제는 `합이 0`인 경우를 구하는 것이며, 원소가 음수일 경우 `max_sum` 계산이 중요합니다.

---

### 🚀 **더 복잡한 예: 부분집합의 합이 특정 값보다 크거나 같은 경우의 수**

- `DP[mask]` = `mask`에 해당하는 부분집합의 합
- 모든 부분집합에 대해 합을 계산하고, 조건에 맞는 경우를 세기

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    int total = 0;
    for (int x : arr) total += x;

    vector<int> dp(1 << n, 0);
    dp[0] = 1;

    for (int i = 0; i < n; i++) {
        for (int mask = (1 << n) - 1; mask >= 0; mask--) {
            if (dp[mask] == 0) continue;
            int new_mask = mask | (1 << i);
            int sum = 0;
            for (int j = 0; j < i; j++) {
                if (mask & (1 << j)) sum += arr[j];
            }
            // 더 효율적인 방법: DP를 합으로 나누기
        }
    }

    // 더 간단한 접근: 각 원소를 추가하면서 합을 갱신
    vector<int> dp_sum(1 << n, 0);
    dp_sum[0] = 1;

    for (int i = 0; i < n; i++) {
        vector<int> new_dp = dp_sum;
        for (int mask = 0; mask < (1 << n); mask++) {
            if (dp_sum[mask] > 0) {
                int new_mask = mask | (1 << i);
                new_dp[new_mask] += dp_sum[mask];
            }
        }
        dp_sum = new_dp;
    }

    // 예: 합이 10 이상인 경우의 수
    int count = 0;
    for (int i = 0; i < (1 << n); i++) {
        int sum = 0;
        for (int j = 0; j < n; j++) {
            if (i & (1 << j)) sum += arr[j];
        }
        if (sum >= 10) count++;
    }
    cout << count << endl;
    return 0;
}
```

> ⚠️ **주의**: 위 코드는 시간 복잡도 $O(2^n \cdot n)$이므로, $n \leq 20$ 이하에서만 효율적입니다.  
> $n > 20$ 이면 **비트마스킹 DP는 실용적이지 않음** → **메모리/시간 제약**이 큼.

---

### 🎯 **DP on Subsets의 주요 특징**

| 항목 | 설명 |
|------|------|
| **상태 정의** | `DP[mask]` = `mask`에 해당하는 부분집합의 성질 (합, 개수, 최대값 등) |
| **전이 방식** | 각 원소를 포함/미포함으로 상태를 확장 (비트 연산 활용) |
| **시간 복잡도** | $O(n \cdot 2^n)$ → $n$이 크면 비효율적 |
| **적합한 문제** | $n \leq 18~20$, 조합 문제, 포함-배제, 부분집합의 성질 문제 |

---

### 📚 **응용 예시**

| 문제 | 설명 |
|------|------|
| **Fibonacci 수열의 부분집합 합** | 부분집합의 합이 특정 값이 되는 경우의 수 |
| **부분집합의 최대/최소 합** | 각 부분집합의 합을 저장하고 최대/최소를 찾음 |
| **부분집합의 크기 제한** | 크기가 홀수인 부분집합의 수 구하기 |
| **FMT (Fast Walsh Transform)** | 부분집합 DP를 더 효율적으로 처리하기 위한 수학적 변환 (고급) |

---

### ✅ **실무 팁**

1. **비트마스킹은 $n \leq 20$ 이하에서 유용**  
   - $n > 20$ 이면 $2^{20} \approx 10^6$, $2^{25} \approx 33M$ → 메모리/시간 부족

2. **DP 상태를 합, 크기, 포함 여부 등으로 정의**  
   - 예: `DP[i][j]` = `i`개의 원소 중 `j`개를 선택하는 경우의 수 (조합 문제)

3. **포함-배제 원리와 결합**  
   - 예: `n`개 중에서 짝수 개를 선택하는 경우의 수는 $2^{n-1}$ (이론적 결과)

4. **FMT (Fast Walsh-Hadamard Transform)**  
   - 부분집합 DP를 더 빠르게 계산할 수 있도록 최적화 (ICPC 고난도 문제에서 자주 사용)

---

### 📌 결론

- **DP on Subsets**는 **비트마스킹 + DP**를 통해 부분집합의 성질을 효율적으로 계산하는 기법입니다.
- 주로 **조합 문제**, **부분집합의 수/합/최대값** 등에 사용
- $n$이 크면 **시간/메모리 제약**이 있음 → **FMT 또는 다른 최적화 기법** 필요
- ICPC/IOI 문제에서 **고난도 조합 문제**에서 자주 등장

> 💡 **추천 학습 순서**:  
> 1. 기본 비트마스킹 DP (예: 부분집합의 합)  
> 2. 포함-배제 원리와 결합  
> 3. FMT를 활용한 고급 DP (고급 문제 해결)

---

📌 **예시 문제 제안** (자기 테스트용):
- `n=5`, 배열: `[1,2,3,4,5]` → 합이 10인 부분집합의 수를 구하라.
- `n=4`, 배열: `[1,2,3,4]` → 짝수 개의 원소를 포함하는 부분집합의 수를 구하라.
- `n=6`, 배열: `[1,2,3,4,5,6]` → 부분집합의 합이 10보다 크거나 같은 경우의 수를 구하라.

이 내용을 기반으로, **DP on Subsets**는 고급 DP 중에서도 **조합 문제 해결에 매우 유용한 기법**입니다.

---

- **CHT (Convex Hull Trick, 볼록 껍질 최적화)**는 DP 점화식이 **직선 형태**를 가질 때, 이를 더 효율적으로 계산하기 위해 **볼록 껍질**(Convex Hull) 기법을 적용하는 고급 최적화 기법입니다.

---

### 🔍 **CHT (Convex Hull Trick) – 핵심 개념**

- **문제 상황**:  
  일반적인 DP 문제에서 점화식이 다음과 같은 형태를 가질 수 있습니다:  
  $$
  dp[i] = \min_{0 \leq j < i} \left( dp[j] + cost(j, i) \right)
  $$  
  여기서 `cost(j, i)`는 `j`에서 `i`로 이동할 때의 비용 함수로, 일반적으로 **선형 함수** 또는 **직선 형태**를 가집니다.

- **핵심 아이디어**:  
  각 `dp[i]`는 여러 직선(각 `j`에 대한 `cost(j, i)`)을 통해 최소값을 구해야 하는데, 이는 시간 복잡도 $O(n^2)$이 됩니다.  
  CHT는 이러한 직선들을 **볼록 껍질**(Convex Hull)로 압축하여, **각 `i`에 대해 최적의 직선을 $O(1)$ 또는 $O(\log n)$**으로 찾는 데 사용합니다.

- **적합한 문제 유형**:  
  - `dp[i] = min_{j < i} (dp[j] + a_j * i + b_j)` 형태의 점화식  
  - `cost(j, i)`가 `i`에 대해 선형 함수인 경우 (예: 거리, 시간, 비용 등)

---

### 📌 **예시 문제: 최소 비용 경로 (Minimum Cost Path with Linear Cost)**

> 주어진 `n`개의 도시에 대해, 각 도시 `i`에서 도시 `j`로 이동할 때의 비용이 `cost = a * (i - j) + b` 형태로 주어질 때, 전체 경로의 최소 비용을 구하라.

#### ✅ 풀이 (CHT 적용)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 1e5 + 5;
const int INF = 1e9;

// 각 도시 j에서 도시 i로 이동할 때의 비용: cost = a * (i - j) + b
// 점화식: dp[i] = min_{j < i} (dp[j] + a * (i - j) + b)

// CHT를 위한 구조: 각 직선 y = a * x + b (a: 기울기, b: 절편)
struct Line {
    long long a, b;
    bool operator<(const Line& other) const {
        return a < other.a; // 기울기 기준 정렬 (볼록 껍질을 위해)
    }
};

// CHT를 위한 최적화: 각 점 i에 대해 최소 비용 직선 찾기
// 이는 점화식이 직선 형태일 때만 가능

int n;
vector<long long> dp;
vector<Line> lines;

// CHT를 위한 큐 (볼록 껍질의 가장 왼쪽, 오른쪽 점)
deque<int> q;

// CHT 함수: 점 i에 대해 최소 비용 직선 찾기
long long solve() {
    dp.assign(n + 1, INF);
    dp[0] = 0;

    for (int i = 1; i <= n; i++) {
        // CHT를 통해 최소 비용 직선 찾기
        while (q.size() >= 2) {
            Line l1 = lines[q[0]];
            Line l2 = lines[q[1]];
            Line l3 = lines[q[2]];

            // 두 직선의 교점이 (x1, y1) = (x2, y2)보다 오른쪽에 있으면 제거
            // (볼록 껍질 유지)
            if (l1.a * (i - 1) + l1.b >= l2.a * (i - 1) + l2.b) {
                q.pop_front();
            } else {
                break;
            }
        }

        // 각 직선에 대해 최소 비용 계산
        for (int j = 0; j < i; j++) {
            long long cost = dp[j] + (long long)(i - j) * 1 + 10; // 예: cost = (i-j) + 10
            if (cost < dp[i]) {
                dp[i] = cost;
            }
        }
    }

    return dp[n];
}
```

> ⚠️ **주의**: 위 예제는 단순한 CHT 구현을 보여주기 위함이며, 실제로는 **각 직선을 정렬하고 교점 계산**을 통해 최적의 직선을 $O(1)$ 또는 $O(\log n)$으로 찾는 **최적화된 CHT 구조**가 필요합니다.

---

### 🚀 **CHT의 핵심 점**

| 항목 | 설명 |
|------|------|
| **전제 조건** | `cost(j, i)`가 `i`에 대해 선형 함수 (예: `a * (i - j) + b`) |
| **시간 복잡도** | 단순 DP: $O(n^2)$ → CHT 적용: $O(n)$ 또는 $O(n \log n)$ |
| **구현 핵심** | - 각 `j`에 대한 직선 `y = a * x + b` 저장<br>- 교점 계산을 통해 최적의 직선 찾기<br>- 볼록 껍질 유지 (monotonic queue) |
| **응용 예시** | - 최소 비용 경로 문제 (예: 거리, 시간)<br>- 최소 비용 구간 문제 (예: 수열 최소합)<br>- 수열 최소화 문제 (예: `dp[i] = min(dp[j] + cost(j, i))`) |

---

### 📚 **응용 예시**

| 문제 | 설명 |
|------|------|
| **최소 비용 경로 (Minimum Cost Path)** | 각 도시 간 비용이 선형 함수인 경우, CHT로 최적 경로를 구함 |
| **최소 비용 구간 (Minimum Cost Subarray)** | 배열의 부분 구간에서 비용이 선형인 경우 최소 비용 구간 찾기 |
| **최소 비용 수열 (Minimum Cost Sequence)** | 수열에서 각 원소 간 비용이 선형인 경우 최소 비용 구하기 |

---

### ✅ **실무 팁**

1. **CHT는 점화식이 선형 함수 형태일 때만 유용**  
   - 비선형 비용 함수(예: 제곱, 지수)는 CHT를 적용할 수 없음

2. **볼록 껍질 유지**:  
   - `q` 큐를 사용하여, 교점이 `i`보다 오른쪽에 있으면 제거  
   - 이는 **볼록 껍질**(Convex Hull)을 유지하는 데 핵심

3. **전체 시간 복잡도**:  
   - $O(n)$ 또는 $O(n \log n)$으로 최적화 가능 (단, 정확한 구현이 필요)

4. **ICPC/IOI 문제에서 자주 등장**  
   - 특히, `dp[i] = min_{j < i} (dp[j] + a * (i - j) + b)` 형태의 문제

---

### 📌 결론

- **CHT (Convex Hull Trick)**는 **DP 점화식이 선형 함수 형태**일 때, **$O(n)$ 또는 $O(n \log n)$**으로 최적화할 수 있는 고급 기법입니다.
- 단순 DP의 $O(n^2)$ 복잡도를 해결하고, 실무/대회 문제에서 **시간 제약을 극복**하는 데 매우 유용합니다.
- **정확한 구현과 교점 계산**이 핵심이며, **문제의 점화식 형태**를 정확히 분석해야 합니다.

> 💡 **추천 학습 순서**:  
> 1. 기본 DP 문제 (예: 최소 비용 경로)  
> 2. 점화식의 선형성 확인 (예: `cost(j, i) = a*(i-j) + b`)  
> 3. CHT 구현 (볼록 껍질 유지, 교점 계산)  
> 4. ICPC/IOI 문제에서의 응용 (예: 최소 비용 경로, 최소 비용 구간)

---

📌 **예시 문제 제안** (자기 테스트용):
- `n=10`, 각 도시 `i`에서 `j`로 이동할 때 비용이 `cost = 2*(i-j) + 10`일 때, 전체 경로의 최소 비용을 구하라.
- `n=5`, 배열 `arr`에서 `dp[i] = min_{j < i} (dp[j] + 3*(i-j) + 5)` 형태의 점화식을 CHT로 최적화하라.

이 내용을 기반으로, **CHT는 고급 DP 최적화 기법 중에서, 선형 비용 함수를 가진 문제에 매우 효과적**입니다.

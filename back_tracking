백트래킹은 문제를 해결하기 위해 가능한 모든 경로를 탐색하면서, 현재 경로가 목적지에 도달하지 못할 경우 그 경로를 "뒤로 가서" 다른 경로를 시도하는 알고리즘입니다. 이는 **재귀적 탐색**과 ** 가지치기**(pruning) 기반으로 작동하며, 특히 **조합 문제**, **배열 순열**, **해밀턴 사이클**, **N-퀸 문제**, **백트래킹으로 수식 풀기** 등에 자주 사용됩니다.

---

### 📌 백트래킹의 핵심 개념

| 개념 | 설명 |
|------|------|
| **탐색 트리** | 각 선택은 트리의 노드로, 현재 선택 후 결과가 불가능하면 그 경로를 끊고 부모 노드로 돌아갑니다. |
| **재귀 구조** | 백트래킹은 일반적으로 재귀 함수로 구현되며, `return` 없이 계속 탐색을 시도합니다. |
| **가지치기**(Pruning) | 현재 상태에서 더 이상 탐색할 필요가 없을 때 (예: 조건을 만족하지 않으면) 조기 종료. |
| **재귀 호출** | 현재 선택 후, 다음 선택을 위해 재귀 호출. 실패 시 `return`으로 돌아가 다음 경로를 시도. |

---

### ✅ 백트래킹의 특징

- **탐색의 효율성**을 위해 가지치기를 통해 불필요한 경우를 제거
- **모든 가능한 경우를 탐색** (예: 1~9 숫자 중 3개를 고르는 조합)
- **결과가 하나 이상일 수 있음** (예: 조합, 순열 등)

---

### 💡 예제: 1~8 숫자 중 3개를 고르는 조합 구하기 (C++)

```cpp
#include <iostream>
#include <vector>
using namespace std;

void backtrack(vector<int>& candidates, vector<int>& current, int start, int target, int& count) {
    // 현재 조합이 목표 길이에 도달했을 경우
    if (current.size() == 3) {
        for (int num : current) {
            cout << num << " ";
        }
        cout << "\n";
        count++;
        return;
    }

    // 가능한 숫자를 탐색 (1~8)
    for (int i = start; i <= 8; i++) {
        // 조합은 중복 없이, 순서는 중요하지 않음
        if (current.size() < 3) {
            current.push_back(i);
            backtrack(candidates, current, i + 1, target, count); // i+1로 시작하여 중복 방지
            current.pop_back(); // 백트래킹: 경로 복귀
        }
    }
}

int main() {
    vector<int> current;
    int count = 0;
    backtrack(vector<int>(), current, 1, 0, count);
    cout << "총 조합 수: " << count << endl;
    return 0;
}
```

> 🔍 **설명**:
> - `start`를 `i+1`로 설정하여 중복을 방지
> - `current.size() == 3`이면 출력하고 `count` 증가
> - `pop_back()`으로 백트래킹 수행

---

### 📚 예시 문제 (추가)

| 문제 | 설명 |
|------|------|
| **N-퀸 문제** | N×N 체스판에서 N개의 퀸을 놓아 서로 공격하지 않게 하기 |
| **수열 조합 (예: 1~4에서 2개 뽑기)** | 조합 문제로, 중복 없이 순서 무관하게 출력 |
| **행복한 수 찾기** | 백트래킹으로 조건을 만족하는 수 찾기 |

---

### ✅ 백트래킹 vs. 순열

| 항목 | 백트래킹 (조합) | 백트래킹 (순열) |
|------|------------------|------------------|
| 중복 여부 | ❌ 중복 불가 | ✅ 중복 가능 (순서 중요) |
| 순서 | 무관 | 관련 |
| 예시 | 1,2,3 → 1,2,3, 1,3,2 등 | 1,2,3 → 1,2,3, 1,3,2, 2,1,3 등 |

---

### 📌 정리

- 백트래킹은 **결과를 모두 찾기 위한 탐색 기법**
- **재귀 + 가지치기**로 효율적으로 문제 해결 가능
- 실무에서는 **가지치기 조건**을 정확히 설정하여 성능 향상

> 💡 팁: `start` 변수를 사용하여 중복 방지, `current.size()`로 조건 체크

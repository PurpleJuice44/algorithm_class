# ğŸ“š íƒìš•ë²• (Greedy Algorithm) â€“ ì „ì²´ ì •ë¦¬

## 1. ì •ì˜ì™€ í•µì‹¬ ì›ë¦¬

**íƒìš•ë²•**(Greedy Algorithm)ì€ **í˜„ì¬ ìƒíƒœì—ì„œ ê°€ì¥ ì¢‹ì€ ì„ íƒ**ì„ í•˜ë©°, **ì§€ê¸ˆì˜ ìµœì  ì„ íƒì„ ê¸°ë°˜ìœ¼ë¡œ ë¯¸ë˜ì˜ ì„ íƒì„ ê²°ì •**í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

> âœ… í•µì‹¬ ì›ì¹™: **"ì§€ê¸ˆ ê°€ì¥ ì¢‹ì€ ì„ íƒì„ í•˜ì"**  
> â†’ ì¦‰, **ì§€ì—­ ìµœì **ì„ ì„ íƒí•´ **ì „ì²´ ìµœì **ìœ¼ë¡œ ì´ì–´ì§€ëŠ” ê²½ìš°ì— ì„±ê³µ

### âœ… íƒìš•ë²•ì˜ íŠ¹ì§•
| í•­ëª© | ì„¤ëª… |
|------|------|
| **ì‹œê°„ íš¨ìœ¨ì„±** | O(n) ë˜ëŠ” O(n log n) ë“±ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì‘ë™ ê°€ëŠ¥ |
| **ê°„ë‹¨í•œ êµ¬í˜„** | ì½”ë“œê°€ ê°„ë‹¨í•˜ê³  ì§ê´€ì  |
| **ì „ì²´ ìµœì  ë³´ì¥ ì—¬ë¶€** | âŒ **ë³´ì¥ë˜ì§€ ì•ŠìŒ** (ì˜ˆ: í¸ì•ˆí•œ ì •ë ¬ ë¬¸ì œ) |

> âš ï¸ **ì£¼ì˜**: íƒìš•ë²•ì´ **ì „ì²´ ìµœì **ì„ ë³´ì¥í•˜ì§€ ì•ŠìŒ.  
> ì˜ˆ: `0/1 ë°°ë‚­ ë¬¸ì œ`ëŠ” íƒìš•ë²•ìœ¼ë¡œëŠ” ìµœì  í•´ë¥¼ ë³´ì¥í•  ìˆ˜ ì—†ìŒ.

---

## 2. íƒìš•ë²•ì˜ ì¥ì ê³¼ í•œê³„

| í•­ëª© | ì„¤ëª… |
|------|------|
| âœ… ì¥ì  | - êµ¬í˜„ ì‰¬ì›€<br>- ì‹œê°„ íš¨ìœ¨ì„± ë†’ìŒ<br>- ì‹¤ìƒí™œ ë¬¸ì œì— ì˜ ì ìš©ë¨ (ì˜ˆ: ìµœì†Œ ë¹„ìš©, ìµœëŒ€ ìˆ˜ìµ) |
| âŒ í•œê³„ | - ì „ì²´ ìµœì ì„ ë³´ì¥í•˜ì§€ ì•ŠìŒ<br>- ë¬¸ì œì˜ êµ¬ì¡°ì— ë”°ë¼ ì‹¤íŒ¨ ê°€ëŠ¥ (ì˜ˆ: í¸ì•ˆí•œ ì •ë ¬ ë¬¸ì œ) |
| ğŸ“Œ ì ìš© ê°€ëŠ¥ ë¬¸ì œ | - ìµœì†Œ ë¹„ìš© ë°°ë‹¬<br>- ìµœëŒ€ ìˆ˜ìµ ë¬¸ì œ<br>- í¸ì•ˆí•œ ì •ë ¬ (activity selection)<br>- ë‹¤ì´ì•„ëª¬ë“œ ë¬¸ì œ (dijkstraì˜ í™•ì¥) |

---

## 3. ì£¼ìš” ë¬¸ì œ ìœ í˜• ë° ì˜ˆì‹œ

### ğŸ”¹ 1. í¸ì•ˆí•œ ì •ë ¬ (Activity Selection Problem)

> **ë¬¸ì œ**: ì—¬ëŸ¬ í™œë™ì´ ì‹œê°„ì— ê²¹ì¹˜ë©´, ìµœëŒ€ ìˆ˜ì˜ í™œë™ì„ ì„ íƒí•˜ë¼.

- **íƒìš•ë²• ì ìš©**: **ì‹œì‘ ì‹œê°„ì´ ê°€ì¥ ë¹ ë¥¸ í™œë™**ë¶€í„° ì„ íƒ
- **ê²°ê³¼**: ìµœëŒ€ ìˆ˜ì˜ í™œë™ ì„ íƒ ê°€ëŠ¥ (ì „ì²´ ìµœì  ë³´ì¥)

#### âœ… ì˜ˆì‹œ
- í™œë™: (ì‹œì‘, ì¢…ë£Œ) â†’ (1,4), (3,5), (0,6), (5,7)
- ìµœì  ì„ íƒ: (0,6), (5,7) â†’ 2ê°œ

---

### ğŸ”¹ 2. ìµœì†Œ ë¹„ìš© ë°°ë‹¬ (Minimum Cost to Connect All Points)

> **ë¬¸ì œ**: Nê°œì˜ ì ì„ ì—°ê²°í•˜ì—¬ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²° (MST ë¬¸ì œ)

- **íƒìš•ë²• ì ìš©**: **í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜**(Kruskal) ë˜ëŠ” **í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜**(Prim)  
- **ê²°ê³¼**: ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (MST) ìƒì„±

---

### ğŸ”¹ 3. ë‹¤ì´ì•„ëª¬ë“œ ë¬¸ì œ (Fractional Knapsack)

> **ë¬¸ì œ**: ë¬´ê²Œ ì œí•œì´ ìˆëŠ” ìƒìì— ë¬¼ê±´ì„ ë„£ì„ ë•Œ, **ìµœëŒ€ ê°€ì¹˜ë¥¼ ì–»ê¸° ìœ„í•´** ëª‡ í¼ì„¼íŠ¸ë¥¼ ë„£ì„ì§€ ê²°ì •

- **íƒìš•ë²• ì ìš©**: **ë‹¨ìœ„ ë¬´ê²Œë‹¹ ê°€ì¹˜ê°€ ê°€ì¥ ë†’ì€ ë¬¼ê±´**ë¶€í„° ì„ íƒ
- âœ… **íƒìš•ë²•ì´ ìµœì  í•´ë¥¼ ë³´ì¥**

---

### ğŸ”¹ 4. ìµœëŒ€ ìˆ˜ìµ ë¬¸ì œ (Job Scheduling)

> **ë¬¸ì œ**: ì—¬ëŸ¬ ì‘ì—…ì„ ìˆ˜í–‰í•  ë•Œ, **ìµœëŒ€ ìˆ˜ìµ**ì„ ì–»ê¸° ìœ„í•´ ì–´ë–¤ ì‘ì—…ì„ ì„ íƒí• ì§€

- **íƒìš•ë²• ì ìš©**: **ìˆ˜ìµì´ ë†’ì€ ì‘ì—…**ë¶€í„° ì„ íƒ (ì‹œê°„ ì œì•½ ìˆìŒ)

---

## 4. C++ ì˜ˆì‹œ ì½”ë“œ (STL ê¸°ë°˜)

---

### âœ… ì˜ˆì‹œ 1: í¸ì•ˆí•œ ì •ë ¬ (Activity Selection)

#### ğŸ“Œ ë¬¸ì œ: ì‹œê°„ì— ê²¹ì¹˜ëŠ” í™œë™ ì¤‘ ìµœëŒ€ ìˆ˜ë¥¼ ì„ íƒ

```cpp
// STL ê¸°ë°˜ (C++11 ì´ìƒ)
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>

using namespace std;

struct Activity {
    int start, end;
    bool operator<(const Activity& a) const {
        return end < a.end; // ì¢…ë£Œ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
    }
};

int maxActivities(const vector<Activity>& acts) {
    sort(acts.begin(), acts.end());
    int count = 1;
    int lastEnd = acts[0].end;

    for (int i = 1; i < acts.size(); ++i) {
        if (acts[i].start >= lastEnd) {
            count++;
            lastEnd = acts[i].end;
        }
    }
    return count;
}

// ì˜ˆì‹œ ì‚¬ìš©
int main() {
    vector<Activity> activities = {
        {1, 4}, {3, 5}, {0, 6}, {5, 7}
    };
    cout << "ìµœëŒ€ í™œë™ ìˆ˜: " << maxActivities(activities) << endl;
    return 0;
}
```
---

### âœ… ì˜ˆì‹œ 2: ë‹¤ì´ì•„ëª¬ë“œ ë¬¸ì œ (Fractional Knapsack)

#### ğŸ“Œ ë¬¸ì œ: ë¬´ê²Œ ì œí•œì´ 10kgì¸ ìƒìì— ë¬¼ê±´ ë„£ê¸°

```cpp
// STL ê¸°ë°˜
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
using namespace std;

struct Item {
    int value, weight;
    double ratio; // ë‹¨ìœ„ ë¬´ê²Œë‹¹ ê°€ì¹˜
    bool operator<(const Item& a) const {
        return ratio > a.ratio; // í° ë¹„ìœ¨ë¶€í„°
    }
};

int fractionalKnapsack(int n, int maxWeight, vector<Item>& items) {
    sort(items.begin(), items.end());
    int totalValue = 0;
    int currentWeight = 0;

    for (int i = 0; i < n; ++i) {
        if (currentWeight + items[i].weight <= maxWeight) {
            currentWeight += items[i].weight;
            totalValue += items[i].value;
        } else {
            double fraction = (double)(maxWeight - currentWeight) / items[i].weight;
            totalValue += items[i].value * fraction;
            break;
        }
    }
    return totalValue;
}

int main() {
    vector<Item> items = {
        {60, 10}, {100, 20}, {120, 30}
    };

    cout << "ìµœëŒ€ ìˆ˜ìµ: " << fractionalKnapsack(3, 50, items) << endl;
    return 0;
}
```

## 5. íƒìš•ë²•ì´ ì„±ê³µí•  ì¡°ê±´

| ì¡°ê±´ | ì„¤ëª… |
|------|------|
| âœ… **ë‹¨ìˆœí•œ ì„ íƒ ê¸°ì¤€** | (ì˜ˆ: ì‹œê°„, ë¹„ìš©, ìˆ˜ìµ ë“±) |
| âœ… **ìµœì  í•˜ìœ„ êµ¬ì¡°** | (ì˜ˆ: ê° ì„ íƒì´ ì „ì²´ ìµœì ì— ê¸°ì—¬) |
| âœ… **ë¬´ê²Œ ì œí•œ ë¬¸ì œ** | (ì˜ˆ: Fractional Knapsack) |
| âŒ **0/1 Knapsack** | íƒìš•ë²•ì€ ìµœì  í•´ë¥¼ ë³´ì¥í•˜ì§€ ì•ŠìŒ |

---

## 6. ìš”ì•½

| í•­ëª© | ë‚´ìš© |
|------|------|
| ğŸ” í•µì‹¬ ì›ë¦¬ | í˜„ì¬ ìµœì  ì„ íƒ â†’ ë¯¸ë˜ ì„ íƒ ê¸°ë°˜ |
| âœ… ì„±ê³µ ì‚¬ë¡€ | Fractional Knapsack, Activity Selection, MST |
| âŒ ì‹¤íŒ¨ ì‚¬ë¡€ | 0/1 Knapsack, ì¼ë¶€ ìµœì í™” ë¬¸ì œ |
| ğŸ’¡ ì¶”ì²œ ì‚¬ìš© | **ì‹œê°„ ì œí•œì´ ì ê³ , ë¹„ìš©/ìˆ˜ìµ/ì‹œê°„ ê¸°ì¤€ì´ ëª…í™•í•œ ë¬¸ì œ**ì— ì í•© |

---

## âœ… ê²°ë¡ 

íƒìš•ë²•ì€ **ê°„ë‹¨í•˜ê³  ë¹ ë¥´ë©° ì‹¤ìƒí™œ ë¬¸ì œì— ë§¤ìš° ìœ ìš©**í•©ë‹ˆë‹¤.  
í•˜ì§€ë§Œ **ì „ì²´ ìµœì ì„ ë³´ì¥í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—**, ë¬¸ì œì˜ êµ¬ì¡°ë¥¼ ì˜ ì´í•´í•˜ê³  **íƒìš•ë²•ì´ ì ìš© ê°€ëŠ¥í•œì§€ íŒë‹¨**í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

> ğŸ“Œ **ìš”ì•½**:  
> - **íƒìš•ë²•ì€ "ì§€ê¸ˆ ê°€ì¥ ì¢‹ì€ ì„ íƒ"ì„ í•˜ë©°, ì „ì²´ ìµœì ì„ ë³´ì¥í•˜ì§€ ì•ŠìŒ**  
> - **STLê³¼ Non-STL ëª¨ë‘ êµ¬í˜„ ê°€ëŠ¥**, ì‹¤ë¬´ì—ì„œ ìœ ì—°í•˜ê²Œ ì‚¬ìš© ê°€ëŠ¥  
> - **ì •í™•í•œ ë¬¸ì œ ë¶„ì„**ì´ í•µì‹¬ (ì˜ˆ: 0/1 vs Fractional)

---

## 시간 복잡도 (Time Complexity) 요약

### 정의
**시간 복잡도**는 알고리즘이 입력 크기 `n`가 증가할 때, **실행 시간이 얼마나 증가하는지**를 나타내는 지표입니다.  
대부분 `O(n^k)` 형태로 표현되며, `n`이 커질수록 성능이 얼마나 나빠지는지를 비교할 수 있습니다.

## 주요 시간 복잡도 종류 (낮음 → 높음)

| 복잡도            | 의미          | 예시                            |                       |
| -------------- | ----------- | ----------------------------- | --------------------- |
| **O(1)**       | 상수 시간       | 배열의 첫 원소 접근 (`arr[0]`)        |                       |
| **O(log n)**   | 로그 시간       | 이진 탐색, 힙 정렬                   |                       |
| **O(n)**       | 선형 시간       | 배열 순회, 단순 검색                  |                       |
| **O(n log n)** | 선형 로그       | 병합 정렬, 힙 정렬                   |                       |
| **O(n²)**      | 제곱 시간       | 두 반복문 (예: 2중 루프)              |                       |
| **O(2ⁿ)**      | 지수 시간       | 모든 부분 집합 탐색 (브루트포스)           |                       |
| **O(n!)**      | 팩토리얼 시간     | 모든 순열 탐색 (최악의 경우)             |                       |
| **Θ(n)**       | 정확한 선형 성능   | 단순 순회 + 조건 검사                 | 입력 크기에 정확히 비례         |
| **Ω(n)**       | 최소 **n** 이상 | 검색이 항상 최소 1번 실행됨              | 최선의 경우를 보장할 때         |
| **Ω(1)**       | 최소 상수 시간    | 해시맵에서 키 찾기 (최선 경우)            | 최소 1ms 내로 응답 가능       |
| **Ω(log n)**   | 최소 로그 시간    | 이진 탐색의 최선 경우 (전체 탐색 없이 바로 찾음) | 최선의 경우가 최소 로그 시간이면 가능 |
| **Ω(n²)**      | 최소 제곱 시간    | 두 반복문이 반드시 실행될 때 (예: 모든 쌍 비교) | 최악의 경우보다 더 느려질 수 있음   |

✅ **Big O (O)**: **최악의 경우**(worst-case)를 기준으로 **상한**(upper bound)을 나타냄  
✅ **Ω (오메가)**: **최선의 경우**(best-case)를 기준으로 **하한**(lower bound)을 나타냄  
✅ **Θ (세타)**: **최악과 최선의 경우**가 거의 동일할 때, **정확한 경계**(tight bound)를 나타냄

*Note: 일반적으로 **O(n log n)** 이하가 효율적이고, **O(n²)** 이상은 큰 데이터에서는 비효율적

## 📈 복잡도 비교 (입력 크기 증가 시)

| 입력 크기 `n` | O(1) | O(n) | O(n²) | O(n log n) | O(2ⁿ) | O(n!) |
|-------------|------|------|--------|------------|--------|--------|
| n = 10 | 1ms | 10ms | 100ms | ~100ms | ~100ms | ~3.6ms |
| n = 100 | 1ms | 100ms | 10,000ms (10초) | ~100ms | **무한** | **매우 큰 값** |

> 💡 예: `n=20`일 때 `O(2ⁿ)`은 약 10⁶, `O(n!)`은 약 10¹⁸ → 현실적으로 불가능

---
## 📌 핵심 요점 정리

| 복잡도      | 의미        | 중요성                        |
| -------- | --------- | -------------------------- |
| **O(n)** | 최악의 경우 최대 | 알고리즘의 상한을 나타냄 (실무에서 주의)    |
| **Ω(n)** | 최선의 경우 최소 | 최소 성능 보장 (예: 최소 1번 반복)     |
| **Θ(n)** | 정확한 경계    | 알고리즘이 효율적이고 일관성 있음 (예: 정렬) |

> ✅ **Big O는 "최악의 경우"를 보여주고**,  
> ✅ **Ω는 "최선의 경우"를 보여주고**,  
> ✅ **Θ는 "정확한 경계"를 보여줌** → 알고리즘의 성능을 더 정확하게 평가 가능
